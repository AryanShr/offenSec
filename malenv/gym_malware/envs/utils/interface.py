from typing import List, Tuple
from enum import Enum
import torch
from typing import Union
from torch import Tensor
import torch.nn as nn
from torch.utils.data import Dataset, DataLoader, Subset
import numpy as np
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.neural_network import MLPClassifier
from sklearn.svm import SVC
from sklearn.ensemble import VotingClassifier
from sklearn.metrics import confusion_matrix, roc_auc_score
from pathlib import Path
import lief
import logging
import re
import pickle
import os
import sys
import glob


TorchOrNumpy = Union[np.ndarray, Tensor]

class EnsembleBlackBoxDetector:
    def __init__(self):
        self.models = [
            ('DecisionTree', DecisionTreeClassifier()),
            ('RandomForest', RandomForestClassifier()),
            ('SVC', SVC(probability=True)),
            ('Logistic', LogisticRegression()),
            ('MLP', MLPClassifier())
        ]
        self.ensemble_model = VotingClassifier(estimators=self.models, voting='soft')
        self.training = True

    def fit(self, X: TorchOrNumpy, y: TorchOrNumpy):
        if isinstance(X, torch.Tensor):
            X = X.numpy()
        if isinstance(y, torch.Tensor):
            y = y.numpy()
        self.ensemble_model.fit(X, y)
        self.training = False

    def predict(self, X: TorchOrNumpy) -> torch.tensor:
        if self.training:
            raise ValueError("Detector does not appear to be trained but trying to predict")
        # if torch.cuda.is_available():
        #     X = X.cpu()
        if isinstance(X, torch.Tensor):
            X = X.numpy()
        # print(X)
        y = torch.from_numpy(self.ensemble_model.predict_proba(X)[:, 1]).float()
        # return y.cuda() if torch.cuda.is_available() else y
        return y
    def save_model(self, filename):
        with open(filename, 'wb') as file:
            pickle.dump(self.ensemble_model, file)

    @classmethod
    def load_model(cls, filename, learner_types):
        with open(filename, 'rb') as file:
            ensemble_model = pickle.load(file)
        ensemble_detector = cls(learner_types)
        ensemble_detector.ensemble_model = ensemble_model
        ensemble_detector.training = False
        return ensemble_detector


logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

def filter_imported_functions(func_string_with_library):
    """
    Filters the returned imported functions of binary to remove those with special characters (lots of noise for some reason),
    and require functions to start with a capital letter since Windows API functions seem to obey Upper Camelcase convension.

    Update: The limitation for the upper case in the preprocessing step has been removed.
    """
    func_string = func_string_with_library.split(":")[0]

    if re.match("^[a-zA-Z]*$", func_string):
        return True
    else:
        return False

def process_imported_functions_output(imports):
    imports = list(filter(lambda x: filter_imported_functions(x), imports))
    # imports = list(map(lambda x: remove_encoding_indicator(x), imports))
    return imports

def feature_generation(PEfile, feature_vector_mapping: dict):
    feature_vector = [0] * len(feature_vector_mapping)

    try:
        binary = PEfile
        imports = [e.name + ':' + lib.name.lower() for lib in binary.imports for e in lib.entries]
        imports = process_imported_functions_output(imports)

        sections = [section.name for section in binary.sections]

        for lib_import in imports:
            if lib_import in feature_vector_mapping:
                index = feature_vector_mapping[lib_import]
                feature_vector[index] = 1

        for section in sections:
            if section in feature_vector_mapping:
                index = feature_vector_mapping[section]
                feature_vector[index] = 1

    except Exception as e:
        logger.error(f"Error parsing PEFile: {str(e)}")
        # You can choose to handle the error differently

    return [feature_vector]

def get_score_local(bytez):
    pe = lief.parse(bytez)
    # feature_vector = pickle.load(open('/media/nerdcoder/New Volume/Major Project/Pesiduos/Pesidious/gym_malware/envs/utils/feature_vector_mapping.pk', 'rb'))
    feature_vector = pickle.load(open('gym_malware\\envs\\utils\\feature_vector_mapping(1).pk', 'rb'))
    features = feature_generation(pe, feature_vector)
    # load_model = pickle.load(open('/media/nerdcoder/New Volume/Major Project/Pesiduos/Pesidious/gym_malware/envs/utils/MalwareScore.pkl', 'rb'))
    load_model = pickle.load(open('gym_malware\\envs\\utils\\MalwareScore(1).pkl', 'rb'))
    score = load_model.predict(features)
    return score.item()

local_model_threshold = 0.60
def get_label_local(bytez):
    # mimic black box by thresholding here
    score = get_score_local(bytez)
    label = float( get_score_local(bytez) >= local_model_threshold )
    #print("score={} (hidden), label={}".format(score,label)) 
    return label

# SAMPLE_PATH = os.path.join("/media/nerdcoder/New Volume/Major Project/Pesiduos/Pesidious/Data/malware")



    

class ClassificationFailure(Exception):
    pass


class FileRetrievalFailure(Exception):
    pass


# def fetch_file(sha256):
#     location = os.path.join(SAMPLE_PATH+'/', sha256 + ".exe")
#     print(location)
#     try:
#         with open(location, 'rb') as infile:
#             bytez = infile.read()
#     except IOError:
#         raise FileRetrievalFailure(
#             "Unable to read sha256 from {}".format(location))

#     return bytez


# def get_available_sha256():
#     sha256list = []
#     for fp in glob.glob(SAMPLE_PATH+"/*"):
#         fn = os.path.split(fp)[-1].removesuffix(".exe")
#         print(fn)
#         result = re.match(r'^[0-9a-fA-F]{64}$', fn) # require filenames to be sha256
#         # print(result)
#         if result:
#             sha256list.append(result.group(0))
#     assert len(sha256list)>0, "no files found in {} with sha256 names".format( SAMPLE_PATH )
#     return sha256list
